Output:
-------
token                         lexeme
------------------------------------
keyword                     function
identifier           testDeclaration
separator                          (
identifier                     value
separator                          ,
identifier                    value1
keyword                          int
separator                          )
separator                          {
keyword                           if
separator                          (
identifier                     value
operator                          ==
integer                            0
separator                          )
separator                          {
identifier                      test
operator                           =
integer                            1
separator                          ;
separator                          }
keyword                         else
separator                          {
identifier                      test
operator                           =
integer                            0
separator                          ;
separator                          }
keyword                           fi
separator                          }
separator                          #
keyword                          int
identifier                      test
separator                          ;
keyword                         bool
identifier                     valid
separator                          ;
separator                          #
identifier                     valid
operator                           =
keyword                         true
separator                          ;
keyword                          put
separator                          (
identifier                     valid
separator                          )
separator                          ;
keyword                          get
separator                          (
identifier                     valid
separator                          )
separator                          ;
keyword                       return
identifier                     valid
separator                          ;
------------------------------------
Token: keyword Lexeme: function
<Rat23S> ::= <Opt Function Definitions> # <Opt Declaration List> # <Statement List>
<Opt Function Definitions> ::= <Function Definitions> | <Empty>
<Function Definitions> ::= <Function> <Function'>
<Function> ::= function <Identifier>(<Opt Parameter List>) <Opt Declaration List> <Body>
Token: identifier Lexeme: testDeclaration
Token: separator Lexeme: (
Token: identifier Lexeme: value
<Opt Parameter List> ::= <Parameter List> | <Empty>
<Parameter List> ::= <Parameter> <Parameter'>
<Parameter> ::= <IDs> <Qualifier>
<IDs> ::= <Identifier> <IDs'>
Token: separator Lexeme: ,
<IDs'> ::= <Empty> | , <IDs>
Token: identifier Lexeme: value1
<IDs> ::= <Identifier> <IDs'>
Token: keyword Lexeme: int
<IDs'> ::= <Empty> | , <IDs>
<Empty> ::= <Empty>
<Qualifier> ::= int | bool | real
Token: separator Lexeme: )
<Parameter'> ::= <Empty> | , <Parameter List>
<Empty> ::= <Empty>
Token: separator Lexeme: {
<Opt Declaration List> ::= <Declaration List> | <Empty>
<Empty> ::= <Empty>
<Body> ::= { <Statement List> }
Token: keyword Lexeme: if
<Statement List> ::= <Statement> <Statement'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<If> ::= if ( <Condition> ) <Statement> <If'>
Token: separator Lexeme: (
Token: identifier Lexeme: value
<Condition> ::= <Expression> <Relop> <Expression>
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> | <Integer> | <Identifier> ( <IDs> ) | ( <Expression> ) | <Real> | true | false
Token: operator Lexeme: ==
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | <Empty>
<Empty> ::= <Empty>
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | <Empty>
<Empty> ::= <Empty>
<Relop> ::= == | != | > | < | <= | =>
Token: integer Lexeme: 0
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> | <Integer> | <Identifier> ( <IDs> ) | ( <Expression> ) | <Real> | true | false
Token: separator Lexeme: )
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | <Empty>
<Empty> ::= <Empty>
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | <Empty>
<Empty> ::= <Empty>
Token: separator Lexeme: {
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Compound> ::= { <Statement List> }
Token: identifier Lexeme: test
<Statement List> ::= <Statement> <Statement'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Assign> ::= <Identifier> = <Expression> ;
Token: operator Lexeme: =
Token: integer Lexeme: 1
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> | <Integer> | <Identifier> ( <IDs> ) | ( <Expression> ) | <Real> | true | false
Token: separator Lexeme: ;
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | <Empty>
<Empty> ::= <Empty>
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | <Empty>
<Empty> ::= <Empty>
Token: separator Lexeme: }
<Statement'> ::= <Empty> | <Statement List>
<Empty> ::= <Empty>
Token: keyword Lexeme: else
<If'> ::= fi | else <Statement> fi
Token: separator Lexeme: {
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Compound> ::= { <Statement List> }
Token: identifier Lexeme: test
<Statement List> ::= <Statement> <Statement'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Assign> ::= <Identifier> = <Expression> ;
Token: operator Lexeme: =
Token: integer Lexeme: 0
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> | <Integer> | <Identifier> ( <IDs> ) | ( <Expression> ) | <Real> | true | false
Token: separator Lexeme: ;
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | <Empty>
<Empty> ::= <Empty>
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | <Empty>
<Empty> ::= <Empty>
Token: separator Lexeme: }
<Statement'> ::= <Empty> | <Statement List>
<Empty> ::= <Empty>
Token: keyword Lexeme: fi
Token: separator Lexeme: }
<Statement'> ::= <Empty> | <Statement List>
<Empty> ::= <Empty>
Token: separator Lexeme: #
<Function'> ::= <Empty> | <Function Definitions>
<Empty> ::= <Empty>
Token: keyword Lexeme: int
<Opt Declaration List> ::= <Declaration List> | <Empty>
<Declaration List> ::= <Declaration> | <Declaration'>
<Declaration> ::= <Qualifier> <IDs>;
<Qualifier> ::= int | bool | real
Token: identifier Lexeme: test
<IDs> ::= <Identifier> <IDs'>
Token: separator Lexeme: ;
<IDs'> ::= <Empty> | , <IDs>
<Empty> ::= <Empty>
Token: keyword Lexeme: bool
<Declaration'> ::= <Empty> | <Declaration List>
<Declaration List> ::= <Declaration> | <Declaration'>
<Declaration> ::= <Qualifier> <IDs>;
<Qualifier> ::= int | bool | real
Token: identifier Lexeme: valid
<IDs> ::= <Identifier> <IDs'>
Token: separator Lexeme: ;
<IDs'> ::= <Empty> | , <IDs>
<Empty> ::= <Empty>
Token: separator Lexeme: #
<Declaration'> ::= <Empty> | <Declaration List>
<Empty> ::= <Empty>
Token: identifier Lexeme: valid
<Statement List> ::= <Statement> <Statement'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Assign> ::= <Identifier> = <Expression> ;
Token: operator Lexeme: =
Token: keyword Lexeme: true
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> | <Integer> | <Identifier> ( <IDs> ) | ( <Expression> ) | <Real> | true | false
Token: separator Lexeme: ;
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | <Empty>
<Empty> ::= <Empty>
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | <Empty>
<Empty> ::= <Empty>
Token: keyword Lexeme: put
<Statement'> ::= <Empty> | <Statement List>
<Statement List> ::= <Statement> <Statement'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Print> ::= put ( <Expression> ) ;
Token: separator Lexeme: (
Token: identifier Lexeme: valid
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> | <Integer> | <Identifier> ( <IDs> ) | ( <Expression> ) | <Real> | true | false
Token: separator Lexeme: )
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | <Empty>
<Empty> ::= <Empty>
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | <Empty>
<Empty> ::= <Empty>
Token: separator Lexeme: ;
Token: keyword Lexeme: get
<Statement'> ::= <Empty> | <Statement List>
<Statement List> ::= <Statement> <Statement'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Scan> ::= get ( <IDs> ) ;
Token: separator Lexeme: (
Token: identifier Lexeme: valid
<IDs> ::= <Identifier> <IDs'>
Token: separator Lexeme: )
<IDs'> ::= <Empty> | , <IDs>
<Empty> ::= <Empty>
Token: separator Lexeme: ;
Token: keyword Lexeme: return
<Statement'> ::= <Empty> | <Statement List>
<Statement List> ::= <Statement> <Statement'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Return> ::= return <Return'>
Token: identifier Lexeme: valid
<Return'> ::= ; | <Expression> ;
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> | <Integer> | <Identifier> ( <IDs> ) | ( <Expression> ) | <Real> | true | false
Token: separator Lexeme: ;
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | <Empty>
<Empty> ::= <Empty>
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | <Empty>
<Empty> ::= <Empty>
<Statement'> ::= <Empty> | <Statement List>
<Empty> ::= <Empty>
